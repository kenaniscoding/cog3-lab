# -*- coding: utf-8 -*-
"""Activity1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pItwQywoLxKbQoLhU-RCWUUuDj3Dfgjm

# CpE Elective 3 Laboratory (LBYCPC4) <br/>
#### Computer Vision and Deep Learning Elective Track
<br/>
<hr style="border:5px solid gray">

## Activity 1: Autoencoders

### Introduction
&emsp;&emsp;&emsp;Autoencoders are a type of neural network that are trained to learn a compressed representation of input data. They are used to reduce dimensionality, denoise data, and even generate new data. The goal of training an autoencoder is to minimize the reconstruction error, meaning the difference between the original input and the reconstructed output should be as small as possible. This forces the autoencoder to learn a meaningful and efficient representation of the data.

Although reconstructing the data might seem like a trivial matter by simply copying the data forward from one layer to another, this is not possible when the number of units in the middle are constricted. In other words, the number of units in each middle layer is typically fewer than that in the input (or
output). As a result, these units hold a reduced representation of the data, and the final layer can no longer reconstruct the data exactly [1]. This general representation of the autoencoder is illustrated in Figure 1.1.

<center><img src="https://drive.google.com/uc?export=view&id=1N_RUjBNfnFI19Ll9UrMNmEg7phGRPu3W"><br/>Figure 1.1. The encoder neural network architecture [1]</center>

### Objectives
- Understand the working principle and architecture of autoencoders
- Build and train an autoencoder using deep learning framework
- Visualize the output of an autoencoder
- Assess the performance of the implemented autoencoder

### Activity
*Note: Before starting the activity, make sure to save a copy of this Colaboratory notebook first in your own Google Drive. To do so, go to File > Save a copy in Drive*

**A. Dimensionality Reduction with Autoencoders**

1. Write the code that will download the [Wine Dataset from UCI ML Repository](https://archive.ics.uci.edu/dataset/109/wine). Perform feature normalization using `MinMaxScaler` from Scikit-Learn library. Then, do a train-test split of the normalized dataset with 20% of the data for testing.
"""

# Import libraries
import numpy as np
import matplotlib.pyplot as plt

from sklearn.datasets import load_wine
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split

# Load the Wine dataset as a Numpy array
# Perform feature normalization using MinMaxScaler
# Perform train-test split with 20% test data
# Save the training data to variable X_train
# Save the testing data to variable X_test
# Save the target to variable y
### --YOUR CODE HERE-- ###

"""2. Build an autoencoder with the architecture illustrated below. Use the Keras `Sequential` object to build it.
<center><img src="https://drive.google.com/uc?export=view&id=128exLfIE21H2PVoz5w5qZn-9lESgzTFK"></center>
"""

# Import functions and classes from Keras library
from keras import Input
from keras.models import Sequential
from keras.layers import Dense

# Create the autoencoder model based from the illustrated model plot
# Save the model as autoencoder_ann variable
### --YOUR CODE HERE-- ###

"""3. Configure the network for training with the Adam optimizer and the loss to mean squared error. Then train the model with a batch size of 10. Use the test data for validation during training. Make sure to save the history of losses per training and validation epoch. Train the model until the validation loss is no more than 0.02."""

# Configure the network for training using the compile method
# Set the optimizer to Adam and determine the appropriate loss function
### --YOUR CODE HERE-- ###

# Train the model using X_train. Use validation with X_test
# Set the batch size to 10 and the verbosity to 2.
# Ensure the validation loss to be no greater than 0.02
# Use early stopping to determine the appropriate training epochs
# Assign the output to hist_autoencoder_ann variable
### --YOUR CODE HERE-- ###

"""4. Plot the training and validation loss per epoch. Place appropriate plot title and axis labels."""

# Extract the losses during training and validation
losses = hist_autoencoder_ann.history["loss"]
validation_losses = hist_autoencoder_ann.history["val_loss"]
epochs = range(1, len(losses) + 1)

# Plot the history of training and validation losses
plt.figure(figsize=(10, 5), constrained_layout=True)
plt.subplot(1, 2, 1)
### --YOUR CODE HERE-- ###

"""5. Extract the encoder subnetwork from the autoencoder. Obtain the output of the encoder for each dataset sample."""

# Extract the encoder subnetwork
encoder_ann = Sequential(autoencoder_ann.layers[:1])

# Obtain the output of the encoder for each dataset sample
# Save the results to X_encoded variable
# The results should include both training and testing data
### --YOUR CODE HERE-- ###

"""6. Execute the code below to obtain a 3D plot of the values returned by the encoder for each dataset sample. Can you distinguish the clusters? Analyze the plot and write observations on the final report."""

# Create a 3D plot of the encoder predictions for each dataset point
fig = plt.figure(1, figsize=(8, 6))
ax = fig.add_subplot(111, projection="3d", elev=45, azim=-45)
ax.scatter(
    X_encoded[:, 0],
    X_encoded[:, 1],
    X_encoded[:, 2],
    c=y,
    s=20
)

# Set titles and axis labels
ax.set_title("Encoder output")
ax.set_xlabel("Component 1")
ax.set_ylabel("Component 2")
ax.set_zlabel("Component 3")

plt.show()

"""7. Execute the code below to perform principal component analysis (PCA) and write the code to plot the transformed datapoints with the first three (3) PCA dimensions. Compare this plot with step A.6. Write your observations on the final report."""

# Import PCA from Scikit-Learn
from sklearn.decomposition import PCA

X_PCA = PCA(n_components=3).fit_transform(np.vstack((X_train, X_test)))

# Create a 3D plot of the PCA components for each dataset point
# Put appropriate title and axis labels
### --YOUR CODE HERE-- ###

"""8. Create another autoencoder model but with only two (2) nodes in the middle. Repeat steps A.3 to A.6. This time, create 2D plots instead of 3D plots to visualize the encoder subnetwork outputs. Is the final validation loss better than the previous model? Can the model clearly separate the targets into distinguishable clusters? Write your observations in the final report."""

# Define another autoencoder with 2 nodes at hidden layer
### --YOUR CODE HERE-- ###

# Configure and train the network
### --YOUR CODE HERE-- ###

# Plot the history of training and validation losses
### --YOUR CODE HERE-- ###

# Obtain the output of the encoder for each dataset sample
### --YOUR CODE HERE-- ###

"""**B. Building a Denoising Convolutional Autoencoder**

1. Write the code that will download and display at least ten (10) samples of the [Fashion MNIST](https://github.com/zalandoresearch/fashion-mnist) dataset.
"""

# Import functions and classes
from keras.datasets import fashion_mnist
from keras.utils import to_categorical

# Load the Fashion MNIST dataset
# Rescale the pixel values to be between 0 and 1
# Save the training images and labels to x_train and y_train variables
# Save the testing images and labels to x_test and y_test variables
# Plot ten (10) images from training set in a single row
### --YOUR CODE HERE-- ###

"""2. Execute the code below to generate a copy of noisy images and display the images."""

# Apply noise to the image
x_train_noisy = x_train + 0.2*np.random.normal(loc=0, scale=1,
                                               size=x_train.shape)
x_test_noisy = x_test + 0.2*np.random.normal(loc=0, scale=1,
                                             size=x_test.shape)

# Ensure that all pixel values are within the range
x_train_noisy = np.clip(x_train_noisy, 0, 1)
x_test_noisy = np.clip(x_test_noisy, 0, 1)

# Plot ten (10) noisy images from training set in a single row
fig, axes = plt.subplots(1, 10, figsize=(10, 10),
                         subplot_kw={'xticks':[], 'yticks':[]},
                         gridspec_kw=dict(hspace=0.1, wspace=0.1))

for i, ax in enumerate(axes.flat):
  ax.imshow(x_train_noisy[i], cmap='binary', interpolation='none')

"""3. Build a denoising autoencoder with the architecture illustrated below.
<center><img src="https://drive.google.com/uc?export=view&id=1KaLOal7SSsvdIySh5rFw3sd0CwanGQDX"></center>
"""

# Import functions and classes
from keras.layers import Conv2D, MaxPooling2D, UpSampling2D

# Create the autoencoder model based from the illustrated model plot
# Save the model as autoencoder_cnn variable
### --YOUR CODE HERE-- ###

"""4. Configure the network for training with the appropriate loss function and an optimizer of your choice. Then train the model with a batch size of 100. Perform validation during training. Make sure to save the history of losses per training and validation epoch."""

# Configure the network for training
### --YOUR CODE HERE-- ###

# Train the model. Perform validation as well
# Set the batch size to 100 and the verbosity to 2
# Ensure the validation loss to be no greater than 0.01
# Use early stopping to determine the appropriate training epochs
# Assign the output to hist_autoencoder_cnn variable
### --YOUR CODE HERE-- ###

"""5. Plot the training and validation loss per epoch. Place appropriate plot title and axis labels."""

# Extract the losses during training and validation
losses = hist_autoencoder_cnn.history["loss"]
validation_losses = hist_autoencoder_cnn.history["val_loss"]
epochs = range(1, len(losses) + 1)

# Plot the history of training and validation losses
plt.figure(figsize=(10, 5), constrained_layout=True)
plt.subplot(1, 2, 1)
### --YOUR CODE HERE-- ###

"""6. Obtain the model output for at least ten (10) noisy test images. Display the input images in the first row and the output images in the second row."""

# Obtain model output for ten (10) input noisy images
# Display both the input noisy images and the output denoised image in two rows
# The first row contains the input noisy images
# The second row contains the output denoised images
### --YOUR CODE HERE-- ###

"""7. For each test image, measure the error of the reconstruction between the original (prior to applying noise) image and the denoised (model output for noisy input) image. Research an appropriate  error measure between these images and justify it in your final report. Furthermore, take the average of errors across all test images and put the value in your final report."""

### --YOUR CODE HERE-- ###

"""8. Look for at least five (5) images of clothing converted to normalized grayscale images and with the same size as the training dataset. Apply noise as done in task B.2. Obtain the predictions and display the input images in the first row and the output images in the second row. Put the results and write  observations in the final report."""

### --YOUR CODE HERE-- ###

"""***

### Machine Problems

### References

[1] Aggarwal, Charu C. *Neural Networks and Deep Learning : A Textbook*. 2nd ed. Cham: Springer International Publishing, 2023.

[2] I. Goodfellow, Y. Bengio and A. Courville, *Deep Learning*. MIT Press, 2016.

[3] *Keras 3 API documentation*. https://keras.io/api/

[4] *Wine Dataset*. https://archive.ics.uci.edu/dataset/109/wine

[5] *Fashion MNIST*. https://github.com/zalandoresearch/fashion-mnist
"""